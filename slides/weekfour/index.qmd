---
title: "Basic Cryptography"
subtitle: "Understanding the Implementation of Simple Cryptosystems"
description: "How can I build system cryptography algorithms in Python?"
date: "2024-09-16"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
jupyter: python3
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Security Synapse"
---

# What is cryptography?

::: {.incremental style="margin-top: -0.5em;"}

- Establish secure and confidential communication channels
- Supports creation of digital signatures
- Allows us to support the "AAA principles":
  - Authentication
  - Authorization
  - Accounting
- Ensures that attackers cannot "listen in" to communication
- Ensures *non-repudiation* of digital communication

:::

# *Important Insight*: cryptography is one of the key building blocks of computer security!

# *Key Reminder*: it is deceptively difficult to deploy cryptographic algorithms correctly!

# *Admonition*: avoid the temptation to "roll your own" cryptography algorithms! Problems!

# Creating Simple Cryptosystems

::: incremental

- What is the benefit of studying weak cryptography algorithms like those in
_Cracking Codes with Python_?

    - Understand the basics of cryptography
    - Learn why these systems are not secure
    - Feasibly explore the steps of cryptanalysis

:::

# Cryptography Terms

::: {.incremental style="margin-top: -0.5em;"}

- **Plaintext**: the original message
- **Ciphertext**: the encrypted message
- **Cipher**: the algorithm used to encrypt the message
- **Key**: the secret used to encrypt the message
    - **Symmetric Key**: the same key  to encrypt and decrypt
    - **Asymmetric Key**: different keys to encrypt and decrypt

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.9em;"}

**Key Questions**: What are the trade-offs between different types of keys?
Ways to balance security, privacy, and performance? How?

:::

## Reverse Cipher Program

```{pyodide}
#| autorun: true
#| max-lines: 14
# Reverse Cipher
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
message = 'Three can keep a secret, if two of them are dead.'
translated = ''
i = len(message) - 1
while i >= 0:
    translated = translated + message[i]
    i = i - 1
print(translated)
```

::: {.fragment .fade style="margin-top: 0.05em; font-size: 0.9em;"}

- How does this cipher work?
- Does this cipher have a key?
- How would you break this cipher?
- **Task**: Run this cipher with different `message`s

:::

## Recap on Symmetric Encryption

::: incremental

- **Key Benefit**: symmetric encryption is fast and secure
- **Important Reminder**: always securely exchange the key!

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.05em; font-size: 0.9em;"}

- **Review Questions**:
    - What does a `Fernet` key look like?
    - What are the requirements for a `Fernet` key?
    - What if the `Fernet` key does not match?
    - What is the purpose of the `b` prefix?
    - How can you securely exchange the `key`'s contents?

:::

## Wrapping Up on Encryption

::: {.columns style="margin-top: 0.5em;"}

::: {.column style="font-size: 0.9em;"}

::: fragment

### *Key Concepts*

#### Types of Encryption

- Symmetric
- Asymmetric
- Hashing

#### Important Terms

- Plaintext
- Ciphertext
- Key

:::

:::

::: {.column style="font-size: 0.9em;"}

::: fragment

### *Best Practices*

#### Implementation

- Use established libraries
- Securely manage keys
- Understand the trade-offs

#### Prevention

- No "rolling your own"
- Update and patch packages
- Encrypt sensitive data

:::

:::

:::
