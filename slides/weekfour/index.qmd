---
title: "Basic Cryptography"
subtitle: "Understanding the Implementation of Simple Cryptosystems"
description: "How can I build system cryptography algorithms in Python?"
date: "2024-09-16"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
jupyter: python3
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Security Synapse"
---

# What is cryptography?

::: {.incremental style="margin-top: -0.5em;"}

- Establish secure and confidential communication channels
- Supports creation of digital signatures
- Allows us to support the "AAA principles":
  - Authentication
  - Authorization
  - Accounting
- Ensures that attackers cannot "listen in" to communication
- Ensures *non-repudiation* of digital communication

:::

# *Important Insight*: cryptography is one of the key building blocks of computer security!

# *Key Reminder*: it is deceptively difficult to deploy cryptographic algorithms correctly!

# *Admonition*: avoid the temptation to "roll your own" cryptography algorithms! Problems!

# Creating Simple Cryptosystems

::: incremental

- What is the benefit of studying weak cryptography algorithms like those in
_Cracking Codes with Python_?

    - Understand the basics of cryptography
    - Learn why these systems are not secure
    - Feasibly explore the steps of cryptanalysis

:::

# Cryptography Terms

::: {.incremental style="margin-top: -0.5em;"}

- **Plaintext**: the original message
- **Ciphertext**: the encrypted message
- **Cipher**: the algorithm used to encrypt the message
- **Key**: the secret used to encrypt the message
    - **Symmetric Key**: the same key  to encrypt and decrypt
    - **Asymmetric Key**: different keys to encrypt and decrypt

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.9em;"}

**Key Questions**: What are the trade-offs between different types of keys?
Ways to balance security, privacy, and performance? How?

:::

## Revisiting Symmetric Encryption

```{pyodide}
#| autorun: true
#| max-lines: 14
from cryptography.fernet import Fernet

def encrypt_string(input_string: str, key: str):
    """Encrypt a string using a symmetric key."""
    # convert the string into bytes
    data_bytes = input_string.encode()
    # create a Fernet object
    fernet = Fernet(key)
    # encrypt and return the data
    encrypted_data = fernet.encrypt(data_bytes)
    return encrypted_data

# generate a symmetric key
generated_key_sym = Fernet.generate_key()
print("Key:", generated_key_sym)
# encrypt the string
ciphertext_output_sym = encrypt_string('Privacy-sensitive data', generated_key_sym)
print("Encrypted Data:", ciphertext_output_sym)
```

## Revisiting Symmetric Decryption

```{pyodide}
#| autorun: false
#| max-lines: 14
from cryptography.fernet import Fernet

def decrypt_string(encrypted_data: bytes, key: str):
    """Decrypt data using a symmetric key."""
    # create a Fernet object
    fernet = Fernet(key)
    # decrypt and return the data
    decrypted_data = fernet.decrypt(encrypted_data)
    return decrypted_data.decode()

# set the ciphertext and the key
ciphertext_input_sym = b'<add encrypted data here>'
key_sym = b'<add generated key here>'
# decrypt the ciphertext and display it
decrypted_ciphertext_sym = decrypt_string(ciphertext_input_sym, key_sym)
print(decrypted_ciphertext_sym)
```

## Recap on Symmetric Encryption

::: incremental

- **Key Benefit**: symmetric encryption is fast and secure
- **Important Reminder**: always securely exchange the key!

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.05em; font-size: 0.9em;"}

- **Review Questions**:
    - What does a `Fernet` key look like?
    - What are the requirements for a `Fernet` key?
    - What if the `Fernet` key does not match?
    - What is the purpose of the `b` prefix?
    - How can you securely exchange the `key`'s contents?

:::

## Revisiting Content Hashing

```{pyodide}
#| autorun: true
#| max-lines: 14
import hashlib

def compute_hash(input_string):
    """Compute the SHA256 hash of a string."""
    # create a new SHA256 hash object
    hash_object = hashlib.sha256()
    # update the hash object with the bytes of the string
    hash_object.update(input_string.encode())
    # get the hexadecimal representation of the hash
    hash_hex = hash_object.hexdigest()
    return hash_hex

# test string: 'This is a test string'
print(compute_hash('This is a test string'))
# create your own strings and display their hashes
# make one string slightly different than the test string!
```

## Exploring Asymmetric Encryption

```{pyodide}
#| autorun: true
#| max-lines: 8
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization

# generate a new private key
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)
# generate the public key from the private key
public_key = private_key.public_key()
# define the plaintext
data = b"Privacy-sensitive data"

# encrypt the data with the public key
ciphertext_output_asym = public_key.encrypt(
    data,
    padding.PKCS1v15()
)
print("Encrypted Data:", ciphertext_output_asym)
```

## Exploring Asymmetric Decryption

```{pyodide}
#| autorun: false
#| max-lines: 15
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization

# decrypt the data with the private key
ciphertext_input_asym = b'<add encrypted data here>'
plaintext_asym = private_key.decrypt(
    ciphertext_input_asym,
    padding.PKCS1v15()
)

print(plaintext_asym)
```

::: fragment

- You must correctly define `ciphertext_input_asym`!
- The `ciphertext` must have the correct length and format

:::

## Recap on Asymmetric Encryption

::: incremental

- **Key Benefit**: supports secure key exchange
- **Important Reminder**: securely store the private key!

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.05em; font-size: 0.9em;"}

- **Review Questions**:
    - What does an `rsa` private key look like?
    - How does `key_size` affect the `rsa` algorithm?
    - What is the purpose of `padding.PKCS1v15()`?
    - What if the `rsa` keys incorrectly?
    - How can you _combine_ symmetric and asymmetric encryption?

:::

## Wrapping Up on Encryption

::: {.columns style="margin-top: 0.5em;"}

::: {.column style="font-size: 0.9em;"}

::: fragment

### *Key Concepts*

#### Types of Encryption

- Symmetric
- Asymmetric
- Hashing

#### Important Terms

- Plaintext
- Ciphertext
- Key

:::

:::

::: {.column style="font-size: 0.9em;"}

::: fragment

### *Best Practices*

#### Implementation

- Use established libraries
- Securely manage keys
- Understand the trade-offs

#### Prevention

- No "rolling your own"
- Update and patch packages
- Encrypt sensitive data

:::

:::

:::
