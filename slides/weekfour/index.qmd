---
title: "Basic Cryptography"
subtitle: "Understanding the Implementation of Simple Cryptosystems"
description: "How can I build system cryptography algorithms in Python?"
date: "2024-09-16"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
jupyter: python3
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Security Synapse"
---

# What is cryptography?

::: {.incremental style="margin-top: -0.5em;"}

- Establish secure and confidential communication channels
- Supports creation of digital signatures
- Allows us to support the "AAA principles":
  - Authentication
  - Authorization
  - Accounting
- Ensures that attackers cannot "listen in" to communication
- Ensures *non-repudiation* of digital communication

:::

# *Important Insight*: cryptography is one of the key building blocks of computer security!

# *Key Reminder*: it is deceptively difficult to deploy cryptographic algorithms correctly!

# *Admonition*: avoid the temptation to "roll your own" cryptography algorithms! Problems!

# Cryptography Terms

::: {.incremental style="margin-top: -0.5em;"}

- **Plaintext**: the original message
- **Ciphertext**: the encrypted message
- **Cipher**: the algorithm used to encrypt the message
- **Key**: the secret used to encrypt the message
    - **Symmetric Key**: the same key  to encrypt and decrypt
    - **Asymmetric Key**: different keys to encrypt and decrypt

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.9em;"}

**Key Questions**: What are the trade-offs between different types of keys?
Ways to balance security, privacy, and performance? How?

:::

# Creating Simple Cryptosystems

::: incremental

- What is the benefit of studying weak cryptography algorithms like those in
_Cracking Codes with Python_?

    - Understand the **basics** of cryptography
    - Learn why these systems are **not secure**
    - Feasibly explore the steps of **cryptanalysis**

:::


## Reverse Cipher Program

```{pyodide}
#| autorun: true
#| max-lines: 14
# Reverse Cipher
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
message = 'Three can keep a secret, if two of them are dead.'
translated = ''
i = len(message) - 1
while i >= 0:
    translated = translated + message[i]
    i = i - 1
print(translated)
```

::: {.fragment .fade style="margin-top: 0.00em; font-size: 0.9em;"}

- How does this cipher work?
- Does this cipher have a key?
- How would you break this cipher?
- **Task**: Run this cipher with different `message`s

:::

## Caesar Cipher Program

```{pyodide}
#| autorun: true
#| max-lines: 15
# Caesar Cipher
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
message = 'This is my secret message.'
key = 13
mode = 'encrypt' # Set to either 'encrypt' or 'decrypt'.
SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'
translated = ''
for symbol in message:
    if symbol in SYMBOLS:
        symbolIndex = SYMBOLS.find(symbol)
        if mode == 'encrypt':
            translatedIndex = symbolIndex + key
        elif mode == 'decrypt':
            translatedIndex = symbolIndex - key
        # handle wraparound, if needed
        if translatedIndex >= len(SYMBOLS):
            translatedIndex = translatedIndex - len(SYMBOLS)
        elif translatedIndex < 0:
            translatedIndex = translatedIndex + len(SYMBOLS)
        translated = translated + SYMBOLS[translatedIndex]
    else:
        # append the symbol without encrypting/decrypting:
        translated = translated + symbol
print(translated)
```

::: {.fragment .fade style="margin-top: 0.00em; font-size: 0.9em;"}

- **Task**: Run this cipher with different `message`s and `mode`s

:::

## Recap on the Caesar Cipher

::: incremental

- **Key Benefit**: basic cryptography algorithm previously used
- **Important Reminder**: easily susceptible to cryptanalysis

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- **Review Questions**:
    - What is the purpose of the `key` variable?
    - What is the purpose of the `mode` variable?
    - What if a letter is not in the `SYMBOLS` string?
    - Why does the algorithm need to handle "wraparound"?
    - Can you explain the assignment of `translated = translated + SYMBOLS[translatedIndex]`?

:::

## Brute Force Caesar Cipher Attack

```{pyodide}
#| autorun: true
#| max-lines: 6
# Caesar Cipher Hacker
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
message = 'guv6Jv6Jz!J6rp5r7Jzr66ntrM'
SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'
for key in range(len(SYMBOLS)):
    translated = ''
    for symbol in message:
        if symbol in SYMBOLS:
            symbolIndex = SYMBOLS.find(symbol)
            translatedIndex = symbolIndex - key
            # Handle the wraparound:
            if translatedIndex < 0:
                translatedIndex = translatedIndex + len(SYMBOLS)
            # Append the decrypted symbol:
            translated = translated + SYMBOLS[translatedIndex]
        else:
            # Append the symbol without encrypting/decrypting:
            translated = translated + symbol
    # Display every possible decryption:
    print('Key #%s: %s' % (key, translated))
```

## Recap on Caesar Cipher Attack

::: incremental

- **Key Insight**: "brute force" means to try all possible keys
- **Important Reminder**: feasible due to the small key space

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- **Review Questions**:
    - Which `key` value ultimately decrypts the message?
    - What is the purpose of the `mode` variable?
    - How does this connect to the encryption technique?
    - Why does the algorithm need to handle "wraparound"?
    - Can you explain the assignment of `symbolIndex = SYMBOLS.find(symbol)`?

:::

## Transposition Cipher Encryption 

```{pyodide}
#| autorun: true
#| max-lines: 15
# Transposition Cipher Encryption
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
def main():
    current_message = 'Common sense is not so common.'
    current_key = 8
    ciphertext = encryptMessage(current_key, current_message)
    print(ciphertext + '|')

def encryptMessage(key, message):
    ciphertext = [''] * key
    # loop through each column in ciphertext:
    for column in range(key):
        currentIndex = column
        # keep looping until currentIndex goes past the message length:
        while currentIndex < len(message):
            # place the character at currentIndex in message at the
            # end of the current column in the ciphertext list
            ciphertext[column] += message[currentIndex]
            # move currentIndex over
            currentIndex += key
    # convert the ciphertext list into a single string value and return it:
    return ''.join(ciphertext)

main()
```

::: {.fragment .fade style="margin-top: 0.00em; font-size: 0.9em;"}

- **Task**: Try different values for `current_message` and `current_key`

:::

## Recapping Transposition Encryption

::: incremental

- **Key Insight**: key space depends on the message's length
- **Important Reminder**: focuses on columnar transposition

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- **Review Questions**:
    - What does it mean if it works in a "columnar" fashion?
    - Is this more difficult to break than the Caesar cipher?
    - How does this connect to the encryption technique?
    - What are the functions inside of this algorithm?
    - What is the purpose of the `|` character in the output?

:::

## Transposition Cipher Decryption

```{pyodide}
#| autorun: true
#| max-lines: 16
# Transposition Cipher Decryption
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
import math
def main():
    current_message = 'Cenoonommstmme oo snnio. s s c'
    current_key = 8
    plaintext = decryptMessage(current_key, current_message)
    print(plaintext + '|')

def decryptMessage(key, message):
    numOfColumns = int(math.ceil(len(message) / float(key)))
    numOfRows = key
    # the number of "shaded boxes" in the last "column" of the grid
    numOfShadedBoxes = (numOfColumns * numOfRows) - len(message)
    # each string in plaintext represents a column in the grid:
    plaintext = [''] * numOfColumns
    column = 0
    row = 0
    for symbol in message:
        plaintext[column] += symbol
        column += 1
        # if there are no more columns OR we're at a shaded box, go back
        # to the first column and the next row:
        if (column == numOfColumns) or (column == numOfColumns - 1 and
            row >= numOfRows - numOfShadedBoxes):
            column = 0
            row += 1
    return ''.join(plaintext)

main()
```

## Recapping Transposition Decryption

::: incremental

- **Key Insight**: assumes knowledge of share secret key
- **Important Reminder**: decryption different than encryption

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- **Review Questions**:
    - Recovers plaintext by reading columns from a grid
    - Blank, not needed, cells appear at end of the grid
    - Must use the same key for encryption and decryption
    - Purpose of `int(math.ceil(len(message) / float(key)))`?
    - How do you know that the algorithm worked correctly?

:::

# How to Test a Cipher?

::: {.incremental style="margin-top: -0.5em;"}

- Test the Transposition Cipher to ensure its correctness!
- Generate random messages, encrypt, and then decrypt
- Run for a range of keys, which determine the cipher's shift
- Use random messages and keys, covering various scenarios
- A fixed seed ensures the test is repeatable, aiding debugging
- Decryption fails when message does not match original

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.1em; font-size: 0.80em;"}

**Key Questions**: How can we implement this for the transposition cipher? What
amount of testing is sufficient to confirm correctness?

:::

## Transposition Cipher Testing

::: fragment

<!-- ### Standard Approach -->
<div style="margin-bottom: -10px;"><b>Standard Approach</b></div>

```{mermaid}
%%| echo: false
flowchart LR
  A(Plain Text) --> B[Encryption Algorithm]
  B --> C(Cipher Text)
  C --> D[Decryption Algorithm]
  D --> E(Plain Text)
  style A fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style B fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style C fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style D fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style E fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  linkStyle 0,1,2,3 stroke:#1c1c1c,color:#1c1c1c
```

:::

::: fragment

<div style="margin-bottom: -10px; margin-top: 0.5em;"><b>Iterative Approach</b></div>

```{mermaid}
%%| echo: false
flowchart LR
  B[Start] --> A[Generate Random Message] --> C[Encrypt Message]
  C --> D[Decrypt Message]
  D --> E{Random == Decrypted?}
  E -->|Yes| F[Test Passed]
  E -->|No| G[Test Failed]
  F --> H[End]
  G --> H
  H -->|Repeat| B
  style A fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style B fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style C fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style D fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style E fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style F fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style G fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  style H fill:#fff,color:#1c1c1c,stroke:#1c1c1c,stroke-width:2px
  linkStyle 0,1,2,3,4,5,6,7,8 stroke:#1c1c1c,color:#1c1c1c
```

:::

::: {.fragment .fade style="margin-top: 0.1em; font-size: 0.825em;"}

Repeatedly generate random messages, checking cipher output each round!
Continue testing process until you have established confidence in the cipher

:::

## Testing the Transposition Cipher

```{pyodide}
#| autorun: true
#| max-lines: 10
# Transposition Cipher Test
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
import random, sys
def main():
    random.seed(42)
    for i in range(10):
        # generate random messages to test;
        # the message will have a random length
        message = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' * random.randint(4, 40)
        # convert the message string to a list to shuffle it:
        message = list(message)
        random.shuffle(message)
        message = ''.join(message) # Convert the list back to a string.
        print('Test #%s: "%s..."' % (i + 1, message[:50]))
        # check all possible keys for each message:
        for key in range(1, int(len(message)/2)):
            encrypted = encryptMessage(key, message)
            decrypted = decryptMessage(key, encrypted)
            # if the decryption doesn't match the original message, display
            # an error message and quit to highlight the problematic input
            if message != decrypted:
                print('Mismatch with key %s and message %s.' % (key, message))
                print('Decrypted as: ' + decrypted)
                sys.exit()
    print('Transposition cipher test passed.')

main()
```

## Wrapping Up on Basic Cryptography

::: {.columns style="margin-top: 0.5em;"}

::: {.column style="font-size: 0.9em;"}

::: fragment

### *Key Concepts*

#### Studied Algorithms

- Reverse
- Caesar
- Transposition

#### Important Terms

- Plaintext
- Ciphertext
- Brute force attack

:::

:::

::: {.column style="font-size: 0.9em;"}

::: fragment

### *Best Practices*

#### Implementation

- Hone intuition
- Know why not secure
- Practice cryptanalysis

#### Exploration

- See connections
- Make combinations
- Build your toolkit

:::

:::

:::
