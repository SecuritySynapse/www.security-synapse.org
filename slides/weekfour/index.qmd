---
title: "Basic Cryptography"
subtitle: "Understanding the Implementation of Simple Cryptosystems"
description: "How can I build system cryptography algorithms in Python?"
date: "2024-09-16"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
jupyter: python3
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Security Synapse"
---

# What is cryptography?

::: {.incremental style="margin-top: -0.5em;"}

- Establish secure and confidential communication channels
- Supports creation of digital signatures
- Allows us to support the "AAA principles":
  - Authentication
  - Authorization
  - Accounting
- Ensures that attackers cannot "listen in" to communication
- Ensures *non-repudiation* of digital communication

:::

# *Important Insight*: cryptography is one of the key building blocks of computer security!

# *Key Reminder*: it is deceptively difficult to deploy cryptographic algorithms correctly!

# *Admonition*: avoid the temptation to "roll your own" cryptography algorithms! Problems!

# Cryptography Terms

::: {.incremental style="margin-top: -0.5em;"}

- **Plaintext**: the original message
- **Ciphertext**: the encrypted message
- **Cipher**: the algorithm used to encrypt the message
- **Key**: the secret used to encrypt the message
    - **Symmetric Key**: the same key  to encrypt and decrypt
    - **Asymmetric Key**: different keys to encrypt and decrypt

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.9em;"}

**Key Questions**: What are the trade-offs between different types of keys?
Ways to balance security, privacy, and performance? How?

:::

# Creating Simple Cryptosystems

::: incremental

- What is the benefit of studying weak cryptography algorithms like those in
_Cracking Codes with Python_?

    - Understand the **basics** of cryptography
    - Learn why these systems are **not secure**
    - Feasibly explore the steps of **cryptanalysis**

:::


## Reverse Cipher Program

```{pyodide}
#| autorun: true
#| max-lines: 14
# Reverse Cipher
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
message = 'Three can keep a secret, if two of them are dead.'
translated = ''
i = len(message) - 1
while i >= 0:
    translated = translated + message[i]
    i = i - 1
print(translated)
```

::: {.fragment .fade style="margin-top: 0.00em; font-size: 0.9em;"}

- How does this cipher work?
- Does this cipher have a key?
- How would you break this cipher?
- **Task**: Run this cipher with different `message`s

:::

## Caesar Cipher Program

```{pyodide}
#| autorun: true
#| max-lines: 15
# Caesar Cipher
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
message = 'This is my secret message.'
key = 13
mode = 'encrypt' # Set to either 'encrypt' or 'decrypt'.
SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'
translated = ''
for symbol in message:
    if symbol in SYMBOLS:
        symbolIndex = SYMBOLS.find(symbol)
        if mode == 'encrypt':
            translatedIndex = symbolIndex + key
        elif mode == 'decrypt':
            translatedIndex = symbolIndex - key
        # handle wraparound, if needed
        if translatedIndex >= len(SYMBOLS):
            translatedIndex = translatedIndex - len(SYMBOLS)
        elif translatedIndex < 0:
            translatedIndex = translatedIndex + len(SYMBOLS)
        translated = translated + SYMBOLS[translatedIndex]
    else:
        # append the symbol without encrypting/decrypting:
        translated = translated + symbol
print(translated)
```

::: {.fragment .fade style="margin-top: 0.00em; font-size: 0.9em;"}

- **Task**: Run this cipher with different `message`s and `mode`s

:::

## Recap on the Caesar Cipher

::: incremental

- **Key Benefit**: basic cryptography algorithm previously used
- **Important Reminder**: easily susceptible to cryptanalysis

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- **Review Questions**:
    - What is the purpose of the `key` variable?
    - What is the purpose of the `mode` variable?
    - What if a letter is not in the `SYMBOLS` string?
    - Why does the algorithm need to handle "wraparound"?
    - Can you explain the assignment of `translated = translated + SYMBOLS[translatedIndex]`?

:::

## Brute Force Caesar Cipher Attack

```{pyodide}
#| autorun: true
#| max-lines: 6
# Caesar Cipher Hacker
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
message = 'guv6Jv6Jz!J6rp5r7Jzr66ntrM'
SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'
for key in range(len(SYMBOLS)):
    translated = ''
    for symbol in message:
        if symbol in SYMBOLS:
            symbolIndex = SYMBOLS.find(symbol)
            translatedIndex = symbolIndex - key
            # Handle the wraparound:
            if translatedIndex < 0:
                translatedIndex = translatedIndex + len(SYMBOLS)
            # Append the decrypted symbol:
            translated = translated + SYMBOLS[translatedIndex]
        else:
            # Append the symbol without encrypting/decrypting:
            translated = translated + symbol
    # Display every possible decryption:
    print('Key #%s: %s' % (key, translated))
```

## Recap on Caesar Cipher Attack

::: incremental

- **Key Insight**: "brute force" means to try all possible keys
- **Important Reminder**: feasible due to the small key space

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- **Review Questions**:
    - Which `key` value ultimately decrypts the message?
    - What is the purpose of the `mode` variable?
    - How does this connect to the encryption technique?
    - Why does the algorithm need to handle "wraparound"?
    - Can you explain the assignment of `symbolIndex = SYMBOLS.find(symbol)`?

:::

## Transposition Cipher Encryption 

```{pyodide}
#| autorun: true
#| max-lines: 15
# Transposition Cipher Encryption
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
def main():
    current_message = 'Common sense is not so common.'
    current_key = 8
    ciphertext = encryptMessage(current_key, current_message)
    print(ciphertext + '|')

def encryptMessage(key, message):
    ciphertext = [''] * key
    # loop through each column in ciphertext:
    for column in range(key):
        currentIndex = column
        # keep looping until currentIndex goes past the message length:
        while currentIndex < len(message):
            # place the character at currentIndex in message at the
            # end of the current column in the ciphertext list
            ciphertext[column] += message[currentIndex]
            # move currentIndex over
            currentIndex += key
    # convert the ciphertext list into a single string value and return it:
    return ''.join(ciphertext)

main()
```

::: {.fragment .fade style="margin-top: 0.00em; font-size: 0.9em;"}

- **Task**: Try different values for `current_message` and `current_key`

:::

## Recapping Transposition Encryption

::: incremental

- **Key Insight**: key space depends on the message's length
- **Important Reminder**: focuses on columnar transposition

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- **Review Questions**:
    - What does it mean if it works in a "columnar" fashion?
    - Is this more difficult to break than the Caesar cipher?
    - How does this connect to the encryption technique?
    - What are the functions inside of this algorithm?
    - What is the purpose of the `|` character in the output?

:::

## Transposition Cipher Decryption

```{pyodide}
#| autorun: true
#| max-lines: 15
# Transposition Cipher Decryption
# https://www.nostarch.com/crackingcodes/ (BSD Licensed)
import math
def main():
    myMessage = 'Cenoonommstmme oo snnio. s s c'
    myKey = 8
    plaintext = decryptMessage(myKey, myMessage)
    print(plaintext + '|')

def decryptMessage(key, message):
    numOfColumns = int(math.ceil(len(message) / float(key)))
    numOfRows = key
    # The number of "shaded boxes" in the last "column" of the grid:
    numOfShadedBoxes = (numOfColumns * numOfRows) - len(message)
    # Each string in plaintext represents a column in the grid:
    plaintext = [''] * numOfColumns
    # The column and row variables point to where in the grid the next
    # character in the encrypted message will go:
    column = 0
    row = 0
    for symbol in message:
        plaintext[column] += symbol
        column += 1 # Point to the next column.
        # If there are no more columns OR we're at a shaded box, go back
        # to the first column and the next row:
        if (column == numOfColumns) or (column == numOfColumns - 1 and
            row >= numOfRows - numOfShadedBoxes):
            column = 0
            row += 1
    return ''.join(plaintext)

main()
```

::: {.fragment .fade style="margin-top: 0.00em; font-size: 0.9em;"}

- **Task**: Try different values for `current_message` and `current_key`

:::

## Wrapping Up on Encryption

::: {.columns style="margin-top: 0.5em;"}

::: {.column style="font-size: 0.9em;"}

::: fragment

### *Key Concepts*

#### Studied Algorithms

- Reverse
- Caesar
- Transposition

#### Important Terms

- Plaintext
- Ciphertext
- Brute force attack

:::

:::

::: {.column style="font-size: 0.9em;"}

::: fragment

### *Best Practices*

#### Implementation

- Hone intuition
- Know why not secure
- Practice cryptanalysis

#### Exploration

- See connections
- Make combinations
- Build your toolkit

:::

:::

:::
